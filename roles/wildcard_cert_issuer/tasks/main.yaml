- name: Create issuer directories
  when: wildcard_cert_issuer_enabled | bool
  block:
    - name: Create issuer directories
      ansible.builtin.file:
        path: "{{ item }}"
        state: directory
        mode: "0750"
      loop:
        - "{{ wildcard_cert_issuer_letsencrypt_dir }}"
        - "{{ wildcard_cert_issuer_work_dir }}"
        - "{{ wildcard_cert_issuer_config_dir }}"
        - "{{ wildcard_cert_issuer_publish_dir }}"

    - name: Assert PSK is set when publishing is enabled
      ansible.builtin.fail:
        msg: "wildcard_cert_issuer_publish_psk must be set (use Ansible Vault) when publishing is enabled."
      when:
        - wildcard_cert_issuer_publish_enabled | bool
        - (wildcard_cert_issuer_publish_psk is not defined or wildcard_cert_issuer_publish_psk | length == 0)

    - name: Read TSIG key file (bind key syntax)
      ansible.builtin.slurp:
        path: "{{ wildcard_cert_issuer_tsig_keyfile }}"
      register: tsig_keyfile_slurp

    - name: Extract TSIG secret (base64) from key file
      ansible.builtin.set_fact:
        wildcard_cert_issuer_tsig_secret: >-
          {{
            (tsig_keyfile_slurp.content | b64decode)
            | regex_search('secret\s+"([^"]+)"', '\1')
            | first
          }}

    - name: Fail if TSIG secret could not be parsed
      ansible.builtin.fail:
        msg: "Could not parse TSIG secret from {{ wildcard_cert_issuer_tsig_keyfile }}"
      when: not wildcard_cert_issuer_tsig_secret

    - name: Render RFC2136 credentials
      ansible.builtin.copy:
        dest: "{{ wildcard_cert_issuer_config_dir }}/rfc2136.ini"
        mode: "0600"
        content: |
          dns_rfc2136_server = {{ wildcard_cert_issuer_rfc2136_server }}
          dns_rfc2136_port = {{ wildcard_cert_issuer_rfc2136_port }}
          dns_rfc2136_name = {{ wildcard_cert_issuer_tsig_name }}
          dns_rfc2136_secret = {{ wildcard_cert_issuer_tsig_secret }}
          dns_rfc2136_algorithm = {{ wildcard_cert_issuer_tsig_algorithm | upper }}

    - name: Install deploy-hook (package + encrypt with PSK var)
      ansible.builtin.copy:
        dest: "{{ wildcard_cert_issuer_config_dir }}/package_and_encrypt.sh"
        mode: "0755"
        content: "{{ wildcard_cert_issuer_deploy_hook }}"
      when: wildcard_cert_issuer_publish_enabled | bool

    - name: Check if live cert already exists
      ansible.builtin.stat:
        path: "{{ wildcard_cert_issuer_letsencrypt_dir }}/live/{{ wildcard_cert_issuer_base_domain }}/fullchain.pem"
      register: live_cert_stat

    - name: One-time initial issuance
      community.docker.docker_container:
        name: "{{ wildcard_cert_issuer_container_name }}-init"
        image: "{{ wildcard_cert_issuer_image }}"
        auto_remove: true
        detach: false
        network_mode: "{{ wildcard_cert_issuer_container_network_mode }}"
        networks: "{{ wildcard_cert_issuer_container_networks }}"
        env: "{{ wildcard_cert_issuer_container_env }}"
        ports: "{{ wildcard_cert_issuer_container_ports }}"
        volumes: "{{ wildcard_cert_issuer_container_volumes }}"
        command: "{{ wildcard_cert_issuer_container_init_command }}"
      when: not live_cert_stat.stat.exists

    - name: Start renewal loop container (with deploy-hook)
      community.docker.docker_container:
        name: "{{ wildcard_cert_issuer_container_name }}"
        image: "{{ wildcard_cert_issuer_image }}"
        state: started
        restart_policy: always
        network_mode: "{{ wildcard_cert_issuer_container_network_mode }}"
        networks: "{{ wildcard_cert_issuer_container_networks }}"
        env: "{{ wildcard_cert_issuer_container_env }}"
        ports: "{{ wildcard_cert_issuer_container_ports }}"
        volumes: "{{ wildcard_cert_issuer_container_volumes }}"
        entrypoint: ["/bin/sh", "-c"]
        command: ["{{ wildcard_cert_issuer_container_renew_command }}"]
